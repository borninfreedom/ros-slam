//#line 2 "/opt/ros/kinetic/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"
// *********************************************************
//
// File autogenerated for the teb_local_planner package
// by the dynamic_reconfigure package.
// Please do not edit.
//
// ********************************************************/

#ifndef __teb_local_planner__TEBLOCALPLANNERRECONFIGURECONFIG_H__
#define __teb_local_planner__TEBLOCALPLANNERRECONFIGURECONFIG_H__

#if __cplusplus >= 201103L
#define DYNAMIC_RECONFIGURE_FINAL final
#else
#define DYNAMIC_RECONFIGURE_FINAL
#endif

#include <dynamic_reconfigure/config_tools.h>
#include <limits>
#include <ros/node_handle.h>
#include <dynamic_reconfigure/ConfigDescription.h>
#include <dynamic_reconfigure/ParamDescription.h>
#include <dynamic_reconfigure/Group.h>
#include <dynamic_reconfigure/config_init_mutex.h>
#include <boost/any.hpp>

namespace teb_local_planner
{
  class TebLocalPlannerReconfigureConfigStatics;

  class TebLocalPlannerReconfigureConfig
  {
  public:
    class AbstractParamDescription : public dynamic_reconfigure::ParamDescription
    {
    public:
      AbstractParamDescription(std::string n, std::string t, uint32_t l,
          std::string d, std::string e)
      {
        name = n;
        type = t;
        level = l;
        description = d;
        edit_method = e;
      }

      virtual void clamp(TebLocalPlannerReconfigureConfig &config, const TebLocalPlannerReconfigureConfig &max, const TebLocalPlannerReconfigureConfig &min) const = 0;
      virtual void calcLevel(uint32_t &level, const TebLocalPlannerReconfigureConfig &config1, const TebLocalPlannerReconfigureConfig &config2) const = 0;
      virtual void fromServer(const ros::NodeHandle &nh, TebLocalPlannerReconfigureConfig &config) const = 0;
      virtual void toServer(const ros::NodeHandle &nh, const TebLocalPlannerReconfigureConfig &config) const = 0;
      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, TebLocalPlannerReconfigureConfig &config) const = 0;
      virtual void toMessage(dynamic_reconfigure::Config &msg, const TebLocalPlannerReconfigureConfig &config) const = 0;
      virtual void getValue(const TebLocalPlannerReconfigureConfig &config, boost::any &val) const = 0;
    };

    typedef boost::shared_ptr<AbstractParamDescription> AbstractParamDescriptionPtr;
    typedef boost::shared_ptr<const AbstractParamDescription> AbstractParamDescriptionConstPtr;

    // Final keyword added to class because it has virtual methods and inherits
    // from a class with a non-virtual destructor.
    template <class T>
    class ParamDescription DYNAMIC_RECONFIGURE_FINAL : public AbstractParamDescription
    {
    public:
      ParamDescription(std::string a_name, std::string a_type, uint32_t a_level,
          std::string a_description, std::string a_edit_method, T TebLocalPlannerReconfigureConfig::* a_f) :
        AbstractParamDescription(a_name, a_type, a_level, a_description, a_edit_method),
        field(a_f)
      {}

      T (TebLocalPlannerReconfigureConfig::* field);

      virtual void clamp(TebLocalPlannerReconfigureConfig &config, const TebLocalPlannerReconfigureConfig &max, const TebLocalPlannerReconfigureConfig &min) const
      {
        if (config.*field > max.*field)
          config.*field = max.*field;

        if (config.*field < min.*field)
          config.*field = min.*field;
      }

      virtual void calcLevel(uint32_t &comb_level, const TebLocalPlannerReconfigureConfig &config1, const TebLocalPlannerReconfigureConfig &config2) const
      {
        if (config1.*field != config2.*field)
          comb_level |= level;
      }

      virtual void fromServer(const ros::NodeHandle &nh, TebLocalPlannerReconfigureConfig &config) const
      {
        nh.getParam(name, config.*field);
      }

      virtual void toServer(const ros::NodeHandle &nh, const TebLocalPlannerReconfigureConfig &config) const
      {
        nh.setParam(name, config.*field);
      }

      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, TebLocalPlannerReconfigureConfig &config) const
      {
        return dynamic_reconfigure::ConfigTools::getParameter(msg, name, config.*field);
      }

      virtual void toMessage(dynamic_reconfigure::Config &msg, const TebLocalPlannerReconfigureConfig &config) const
      {
        dynamic_reconfigure::ConfigTools::appendParameter(msg, name, config.*field);
      }

      virtual void getValue(const TebLocalPlannerReconfigureConfig &config, boost::any &val) const
      {
        val = config.*field;
      }
    };

    class AbstractGroupDescription : public dynamic_reconfigure::Group
    {
      public:
      AbstractGroupDescription(std::string n, std::string t, int p, int i, bool s)
      {
        name = n;
        type = t;
        parent = p;
        state = s;
        id = i;
      }

      std::vector<AbstractParamDescriptionConstPtr> abstract_parameters;
      bool state;

      virtual void toMessage(dynamic_reconfigure::Config &msg, const boost::any &config) const = 0;
      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, boost::any &config) const =0;
      virtual void updateParams(boost::any &cfg, TebLocalPlannerReconfigureConfig &top) const= 0;
      virtual void setInitialState(boost::any &cfg) const = 0;


      void convertParams()
      {
        for(std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = abstract_parameters.begin(); i != abstract_parameters.end(); ++i)
        {
          parameters.push_back(dynamic_reconfigure::ParamDescription(**i));
        }
      }
    };

    typedef boost::shared_ptr<AbstractGroupDescription> AbstractGroupDescriptionPtr;
    typedef boost::shared_ptr<const AbstractGroupDescription> AbstractGroupDescriptionConstPtr;

    // Final keyword added to class because it has virtual methods and inherits
    // from a class with a non-virtual destructor.
    template<class T, class PT>
    class GroupDescription DYNAMIC_RECONFIGURE_FINAL : public AbstractGroupDescription
    {
    public:
      GroupDescription(std::string a_name, std::string a_type, int a_parent, int a_id, bool a_s, T PT::* a_f) : AbstractGroupDescription(a_name, a_type, a_parent, a_id, a_s), field(a_f)
      {
      }

      GroupDescription(const GroupDescription<T, PT>& g): AbstractGroupDescription(g.name, g.type, g.parent, g.id, g.state), field(g.field), groups(g.groups)
      {
        parameters = g.parameters;
        abstract_parameters = g.abstract_parameters;
      }

      virtual bool fromMessage(const dynamic_reconfigure::Config &msg, boost::any &cfg) const
      {
        PT* config = boost::any_cast<PT*>(cfg);
        if(!dynamic_reconfigure::ConfigTools::getGroupState(msg, name, (*config).*field))
          return false;

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = &((*config).*field);
          if(!(*i)->fromMessage(msg, n))
            return false;
        }

        return true;
      }

      virtual void setInitialState(boost::any &cfg) const
      {
        PT* config = boost::any_cast<PT*>(cfg);
        T* group = &((*config).*field);
        group->state = state;

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = boost::any(&((*config).*field));
          (*i)->setInitialState(n);
        }

      }

      virtual void updateParams(boost::any &cfg, TebLocalPlannerReconfigureConfig &top) const
      {
        PT* config = boost::any_cast<PT*>(cfg);

        T* f = &((*config).*field);
        f->setParams(top, abstract_parameters);

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          boost::any n = &((*config).*field);
          (*i)->updateParams(n, top);
        }
      }

      virtual void toMessage(dynamic_reconfigure::Config &msg, const boost::any &cfg) const
      {
        const PT config = boost::any_cast<PT>(cfg);
        dynamic_reconfigure::ConfigTools::appendGroup<T>(msg, name, id, parent, config.*field);

        for(std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = groups.begin(); i != groups.end(); ++i)
        {
          (*i)->toMessage(msg, config.*field);
        }
      }

      T (PT::* field);
      std::vector<TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr> groups;
    };

class DEFAULT
{
  public:
    DEFAULT()
    {
      state = true;
      name = "Default";
    }

    void setParams(TebLocalPlannerReconfigureConfig &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);


      }
    }

    

    bool state;
    std::string name;

    class TRAJECTORY
{
  public:
    TRAJECTORY()
    {
      state = true;
      name = "Trajectory";
    }

    void setParams(TebLocalPlannerReconfigureConfig &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);

        if("teb_autosize"==(*_i)->name){teb_autosize = boost::any_cast<bool>(val);}
        if("dt_ref"==(*_i)->name){dt_ref = boost::any_cast<double>(val);}
        if("dt_hysteresis"==(*_i)->name){dt_hysteresis = boost::any_cast<double>(val);}
        if("global_plan_overwrite_orientation"==(*_i)->name){global_plan_overwrite_orientation = boost::any_cast<bool>(val);}
        if("allow_init_with_backwards_motion"==(*_i)->name){allow_init_with_backwards_motion = boost::any_cast<bool>(val);}
        if("max_global_plan_lookahead_dist"==(*_i)->name){max_global_plan_lookahead_dist = boost::any_cast<double>(val);}
        if("force_reinit_new_goal_dist"==(*_i)->name){force_reinit_new_goal_dist = boost::any_cast<double>(val);}
        if("feasibility_check_no_poses"==(*_i)->name){feasibility_check_no_poses = boost::any_cast<int>(val);}
        if("exact_arc_length"==(*_i)->name){exact_arc_length = boost::any_cast<bool>(val);}
        if("publish_feedback"==(*_i)->name){publish_feedback = boost::any_cast<bool>(val);}
        if("visualize_with_time_as_z_axis_scale"==(*_i)->name){visualize_with_time_as_z_axis_scale = boost::any_cast<double>(val);}
      }
    }

    bool teb_autosize;
double dt_ref;
double dt_hysteresis;
bool global_plan_overwrite_orientation;
bool allow_init_with_backwards_motion;
double max_global_plan_lookahead_dist;
double force_reinit_new_goal_dist;
int feasibility_check_no_poses;
bool exact_arc_length;
bool publish_feedback;
double visualize_with_time_as_z_axis_scale;

    bool state;
    std::string name;

    
}trajectory;

class VIAPOINTS
{
  public:
    VIAPOINTS()
    {
      state = true;
      name = "ViaPoints";
    }

    void setParams(TebLocalPlannerReconfigureConfig &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);

        if("global_plan_viapoint_sep"==(*_i)->name){global_plan_viapoint_sep = boost::any_cast<double>(val);}
        if("via_points_ordered"==(*_i)->name){via_points_ordered = boost::any_cast<bool>(val);}
      }
    }

    double global_plan_viapoint_sep;
bool via_points_ordered;

    bool state;
    std::string name;

    
}viapoints;

class ROBOT
{
  public:
    ROBOT()
    {
      state = true;
      name = "Robot";
    }

    void setParams(TebLocalPlannerReconfigureConfig &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);

        if("max_vel_x"==(*_i)->name){max_vel_x = boost::any_cast<double>(val);}
        if("max_vel_x_backwards"==(*_i)->name){max_vel_x_backwards = boost::any_cast<double>(val);}
        if("max_vel_theta"==(*_i)->name){max_vel_theta = boost::any_cast<double>(val);}
        if("acc_lim_x"==(*_i)->name){acc_lim_x = boost::any_cast<double>(val);}
        if("acc_lim_theta"==(*_i)->name){acc_lim_theta = boost::any_cast<double>(val);}
        if("is_footprint_dynamic"==(*_i)->name){is_footprint_dynamic = boost::any_cast<bool>(val);}
      }
    }

    double max_vel_x;
double max_vel_x_backwards;
double max_vel_theta;
double acc_lim_x;
double acc_lim_theta;
bool is_footprint_dynamic;

    bool state;
    std::string name;

    class CARLIKE
{
  public:
    CARLIKE()
    {
      state = true;
      name = "Carlike";
    }

    void setParams(TebLocalPlannerReconfigureConfig &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);

        if("min_turning_radius"==(*_i)->name){min_turning_radius = boost::any_cast<double>(val);}
        if("wheelbase"==(*_i)->name){wheelbase = boost::any_cast<double>(val);}
        if("cmd_angle_instead_rotvel"==(*_i)->name){cmd_angle_instead_rotvel = boost::any_cast<bool>(val);}
      }
    }

    double min_turning_radius;
double wheelbase;
bool cmd_angle_instead_rotvel;

    bool state;
    std::string name;

    
}carlike;

class OMNIDIRECTIONAL
{
  public:
    OMNIDIRECTIONAL()
    {
      state = true;
      name = "Omnidirectional";
    }

    void setParams(TebLocalPlannerReconfigureConfig &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);

        if("max_vel_y"==(*_i)->name){max_vel_y = boost::any_cast<double>(val);}
        if("acc_lim_y"==(*_i)->name){acc_lim_y = boost::any_cast<double>(val);}
      }
    }

    double max_vel_y;
double acc_lim_y;

    bool state;
    std::string name;

    
}omnidirectional;

}robot;

class GOALTOLERANCE
{
  public:
    GOALTOLERANCE()
    {
      state = true;
      name = "GoalTolerance";
    }

    void setParams(TebLocalPlannerReconfigureConfig &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);

        if("xy_goal_tolerance"==(*_i)->name){xy_goal_tolerance = boost::any_cast<double>(val);}
        if("yaw_goal_tolerance"==(*_i)->name){yaw_goal_tolerance = boost::any_cast<double>(val);}
        if("free_goal_vel"==(*_i)->name){free_goal_vel = boost::any_cast<bool>(val);}
      }
    }

    double xy_goal_tolerance;
double yaw_goal_tolerance;
bool free_goal_vel;

    bool state;
    std::string name;

    
}goaltolerance;

class OBSTACLES
{
  public:
    OBSTACLES()
    {
      state = true;
      name = "Obstacles";
    }

    void setParams(TebLocalPlannerReconfigureConfig &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);

        if("min_obstacle_dist"==(*_i)->name){min_obstacle_dist = boost::any_cast<double>(val);}
        if("inflation_dist"==(*_i)->name){inflation_dist = boost::any_cast<double>(val);}
        if("dynamic_obstacle_inflation_dist"==(*_i)->name){dynamic_obstacle_inflation_dist = boost::any_cast<double>(val);}
        if("include_dynamic_obstacles"==(*_i)->name){include_dynamic_obstacles = boost::any_cast<bool>(val);}
        if("include_costmap_obstacles"==(*_i)->name){include_costmap_obstacles = boost::any_cast<bool>(val);}
        if("legacy_obstacle_association"==(*_i)->name){legacy_obstacle_association = boost::any_cast<bool>(val);}
        if("obstacle_association_force_inclusion_factor"==(*_i)->name){obstacle_association_force_inclusion_factor = boost::any_cast<double>(val);}
        if("obstacle_association_cutoff_factor"==(*_i)->name){obstacle_association_cutoff_factor = boost::any_cast<double>(val);}
        if("costmap_obstacles_behind_robot_dist"==(*_i)->name){costmap_obstacles_behind_robot_dist = boost::any_cast<double>(val);}
        if("obstacle_poses_affected"==(*_i)->name){obstacle_poses_affected = boost::any_cast<int>(val);}
      }
    }

    double min_obstacle_dist;
double inflation_dist;
double dynamic_obstacle_inflation_dist;
bool include_dynamic_obstacles;
bool include_costmap_obstacles;
bool legacy_obstacle_association;
double obstacle_association_force_inclusion_factor;
double obstacle_association_cutoff_factor;
double costmap_obstacles_behind_robot_dist;
int obstacle_poses_affected;

    bool state;
    std::string name;

    
}obstacles;

class OPTIMIZATION
{
  public:
    OPTIMIZATION()
    {
      state = true;
      name = "Optimization";
    }

    void setParams(TebLocalPlannerReconfigureConfig &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);

        if("no_inner_iterations"==(*_i)->name){no_inner_iterations = boost::any_cast<int>(val);}
        if("no_outer_iterations"==(*_i)->name){no_outer_iterations = boost::any_cast<int>(val);}
        if("optimization_activate"==(*_i)->name){optimization_activate = boost::any_cast<bool>(val);}
        if("optimization_verbose"==(*_i)->name){optimization_verbose = boost::any_cast<bool>(val);}
        if("penalty_epsilon"==(*_i)->name){penalty_epsilon = boost::any_cast<double>(val);}
        if("weight_max_vel_x"==(*_i)->name){weight_max_vel_x = boost::any_cast<double>(val);}
        if("weight_max_vel_y"==(*_i)->name){weight_max_vel_y = boost::any_cast<double>(val);}
        if("weight_max_vel_theta"==(*_i)->name){weight_max_vel_theta = boost::any_cast<double>(val);}
        if("weight_acc_lim_x"==(*_i)->name){weight_acc_lim_x = boost::any_cast<double>(val);}
        if("weight_acc_lim_y"==(*_i)->name){weight_acc_lim_y = boost::any_cast<double>(val);}
        if("weight_acc_lim_theta"==(*_i)->name){weight_acc_lim_theta = boost::any_cast<double>(val);}
        if("weight_kinematics_nh"==(*_i)->name){weight_kinematics_nh = boost::any_cast<double>(val);}
        if("weight_kinematics_forward_drive"==(*_i)->name){weight_kinematics_forward_drive = boost::any_cast<double>(val);}
        if("weight_kinematics_turning_radius"==(*_i)->name){weight_kinematics_turning_radius = boost::any_cast<double>(val);}
        if("weight_optimaltime"==(*_i)->name){weight_optimaltime = boost::any_cast<double>(val);}
        if("weight_obstacle"==(*_i)->name){weight_obstacle = boost::any_cast<double>(val);}
        if("weight_inflation"==(*_i)->name){weight_inflation = boost::any_cast<double>(val);}
        if("weight_dynamic_obstacle"==(*_i)->name){weight_dynamic_obstacle = boost::any_cast<double>(val);}
        if("weight_dynamic_obstacle_inflation"==(*_i)->name){weight_dynamic_obstacle_inflation = boost::any_cast<double>(val);}
        if("weight_viapoint"==(*_i)->name){weight_viapoint = boost::any_cast<double>(val);}
        if("weight_adapt_factor"==(*_i)->name){weight_adapt_factor = boost::any_cast<double>(val);}
      }
    }

    int no_inner_iterations;
int no_outer_iterations;
bool optimization_activate;
bool optimization_verbose;
double penalty_epsilon;
double weight_max_vel_x;
double weight_max_vel_y;
double weight_max_vel_theta;
double weight_acc_lim_x;
double weight_acc_lim_y;
double weight_acc_lim_theta;
double weight_kinematics_nh;
double weight_kinematics_forward_drive;
double weight_kinematics_turning_radius;
double weight_optimaltime;
double weight_obstacle;
double weight_inflation;
double weight_dynamic_obstacle;
double weight_dynamic_obstacle_inflation;
double weight_viapoint;
double weight_adapt_factor;

    bool state;
    std::string name;

    
}optimization;

class HCPLANNING
{
  public:
    HCPLANNING()
    {
      state = true;
      name = "HCPlanning";
    }

    void setParams(TebLocalPlannerReconfigureConfig &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);

        if("enable_multithreading"==(*_i)->name){enable_multithreading = boost::any_cast<bool>(val);}
        if("max_number_classes"==(*_i)->name){max_number_classes = boost::any_cast<int>(val);}
        if("selection_cost_hysteresis"==(*_i)->name){selection_cost_hysteresis = boost::any_cast<double>(val);}
        if("selection_prefer_initial_plan"==(*_i)->name){selection_prefer_initial_plan = boost::any_cast<double>(val);}
        if("selection_obst_cost_scale"==(*_i)->name){selection_obst_cost_scale = boost::any_cast<double>(val);}
        if("selection_viapoint_cost_scale"==(*_i)->name){selection_viapoint_cost_scale = boost::any_cast<double>(val);}
        if("selection_alternative_time_cost"==(*_i)->name){selection_alternative_time_cost = boost::any_cast<bool>(val);}
        if("switching_blocking_period"==(*_i)->name){switching_blocking_period = boost::any_cast<double>(val);}
        if("roadmap_graph_no_samples"==(*_i)->name){roadmap_graph_no_samples = boost::any_cast<int>(val);}
        if("roadmap_graph_area_width"==(*_i)->name){roadmap_graph_area_width = boost::any_cast<double>(val);}
        if("roadmap_graph_area_length_scale"==(*_i)->name){roadmap_graph_area_length_scale = boost::any_cast<double>(val);}
        if("h_signature_prescaler"==(*_i)->name){h_signature_prescaler = boost::any_cast<double>(val);}
        if("h_signature_threshold"==(*_i)->name){h_signature_threshold = boost::any_cast<double>(val);}
        if("obstacle_heading_threshold"==(*_i)->name){obstacle_heading_threshold = boost::any_cast<double>(val);}
        if("viapoints_all_candidates"==(*_i)->name){viapoints_all_candidates = boost::any_cast<bool>(val);}
        if("visualize_hc_graph"==(*_i)->name){visualize_hc_graph = boost::any_cast<bool>(val);}
      }
    }

    bool enable_multithreading;
int max_number_classes;
double selection_cost_hysteresis;
double selection_prefer_initial_plan;
double selection_obst_cost_scale;
double selection_viapoint_cost_scale;
bool selection_alternative_time_cost;
double switching_blocking_period;
int roadmap_graph_no_samples;
double roadmap_graph_area_width;
double roadmap_graph_area_length_scale;
double h_signature_prescaler;
double h_signature_threshold;
double obstacle_heading_threshold;
bool viapoints_all_candidates;
bool visualize_hc_graph;

    bool state;
    std::string name;

    
}hcplanning;

class RECOVERY
{
  public:
    RECOVERY()
    {
      state = true;
      name = "Recovery";
    }

    void setParams(TebLocalPlannerReconfigureConfig &config, const std::vector<AbstractParamDescriptionConstPtr> params)
    {
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator _i = params.begin(); _i != params.end(); ++_i)
      {
        boost::any val;
        (*_i)->getValue(config, val);

        if("shrink_horizon_backup"==(*_i)->name){shrink_horizon_backup = boost::any_cast<bool>(val);}
        if("oscillation_recovery"==(*_i)->name){oscillation_recovery = boost::any_cast<bool>(val);}
      }
    }

    bool shrink_horizon_backup;
bool oscillation_recovery;

    bool state;
    std::string name;

    
}recovery;

}groups;



//#line 23 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool teb_autosize;
//#line 27 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double dt_ref;
//#line 31 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double dt_hysteresis;
//#line 35 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool global_plan_overwrite_orientation;
//#line 39 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool allow_init_with_backwards_motion;
//#line 43 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double max_global_plan_lookahead_dist;
//#line 47 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double force_reinit_new_goal_dist;
//#line 51 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      int feasibility_check_no_poses;
//#line 55 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool exact_arc_length;
//#line 59 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool publish_feedback;
//#line 63 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double visualize_with_time_as_z_axis_scale;
//#line 70 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double global_plan_viapoint_sep;
//#line 74 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool via_points_ordered;
//#line 81 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double max_vel_x;
//#line 85 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double max_vel_x_backwards;
//#line 89 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double max_vel_theta;
//#line 93 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double acc_lim_x;
//#line 97 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double acc_lim_theta;
//#line 101 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool is_footprint_dynamic;
//#line 109 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double min_turning_radius;
//#line 113 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double wheelbase;
//#line 117 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool cmd_angle_instead_rotvel;
//#line 125 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double max_vel_y;
//#line 129 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double acc_lim_y;
//#line 136 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double xy_goal_tolerance;
//#line 140 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double yaw_goal_tolerance;
//#line 144 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool free_goal_vel;
//#line 151 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double min_obstacle_dist;
//#line 155 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double inflation_dist;
//#line 159 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double dynamic_obstacle_inflation_dist;
//#line 163 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool include_dynamic_obstacles;
//#line 167 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool include_costmap_obstacles;
//#line 171 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool legacy_obstacle_association;
//#line 175 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double obstacle_association_force_inclusion_factor;
//#line 179 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double obstacle_association_cutoff_factor;
//#line 183 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double costmap_obstacles_behind_robot_dist;
//#line 187 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      int obstacle_poses_affected;
//#line 195 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      int no_inner_iterations;
//#line 199 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      int no_outer_iterations;
//#line 203 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool optimization_activate;
//#line 207 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool optimization_verbose;
//#line 211 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double penalty_epsilon;
//#line 215 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_max_vel_x;
//#line 219 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_max_vel_y;
//#line 223 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_max_vel_theta;
//#line 227 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_acc_lim_x;
//#line 231 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_acc_lim_y;
//#line 235 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_acc_lim_theta;
//#line 239 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_kinematics_nh;
//#line 243 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_kinematics_forward_drive;
//#line 247 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_kinematics_turning_radius;
//#line 251 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_optimaltime;
//#line 255 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_obstacle;
//#line 259 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_inflation;
//#line 263 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_dynamic_obstacle;
//#line 267 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_dynamic_obstacle_inflation;
//#line 271 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_viapoint;
//#line 275 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double weight_adapt_factor;
//#line 284 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool enable_multithreading;
//#line 288 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      int max_number_classes;
//#line 292 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double selection_cost_hysteresis;
//#line 297 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double selection_prefer_initial_plan;
//#line 301 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double selection_obst_cost_scale;
//#line 305 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double selection_viapoint_cost_scale;
//#line 309 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool selection_alternative_time_cost;
//#line 313 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double switching_blocking_period;
//#line 317 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      int roadmap_graph_no_samples;
//#line 321 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double roadmap_graph_area_width;
//#line 325 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double roadmap_graph_area_length_scale;
//#line 329 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double h_signature_prescaler;
//#line 333 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double h_signature_threshold;
//#line 337 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      double obstacle_heading_threshold;
//#line 341 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool viapoints_all_candidates;
//#line 345 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool visualize_hc_graph;
//#line 353 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool shrink_horizon_backup;
//#line 357 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      bool oscillation_recovery;
//#line 228 "/opt/ros/kinetic/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"

    bool __fromMessage__(dynamic_reconfigure::Config &msg)
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();

      int count = 0;
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        if ((*i)->fromMessage(msg, *this))
          count++;

      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); i ++)
      {
        if ((*i)->id == 0)
        {
          boost::any n = boost::any(this);
          (*i)->updateParams(n, *this);
          (*i)->fromMessage(msg, n);
        }
      }

      if (count != dynamic_reconfigure::ConfigTools::size(msg))
      {
        ROS_ERROR("TebLocalPlannerReconfigureConfig::__fromMessage__ called with an unexpected parameter.");
        ROS_ERROR("Booleans:");
        for (unsigned int i = 0; i < msg.bools.size(); i++)
          ROS_ERROR("  %s", msg.bools[i].name.c_str());
        ROS_ERROR("Integers:");
        for (unsigned int i = 0; i < msg.ints.size(); i++)
          ROS_ERROR("  %s", msg.ints[i].name.c_str());
        ROS_ERROR("Doubles:");
        for (unsigned int i = 0; i < msg.doubles.size(); i++)
          ROS_ERROR("  %s", msg.doubles[i].name.c_str());
        ROS_ERROR("Strings:");
        for (unsigned int i = 0; i < msg.strs.size(); i++)
          ROS_ERROR("  %s", msg.strs[i].name.c_str());
        // @todo Check that there are no duplicates. Make this error more
        // explicit.
        return false;
      }
      return true;
    }

    // This version of __toMessage__ is used during initialization of
    // statics when __getParamDescriptions__ can't be called yet.
    void __toMessage__(dynamic_reconfigure::Config &msg, const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__, const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__) const
    {
      dynamic_reconfigure::ConfigTools::clear(msg);
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->toMessage(msg, *this);

      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); ++i)
      {
        if((*i)->id == 0)
        {
          (*i)->toMessage(msg, *this);
        }
      }
    }

    void __toMessage__(dynamic_reconfigure::Config &msg) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();
      __toMessage__(msg, __param_descriptions__, __group_descriptions__);
    }

    void __toServer__(const ros::NodeHandle &nh) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->toServer(nh, *this);
    }

    void __fromServer__(const ros::NodeHandle &nh)
    {
      static bool setup=false;

      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->fromServer(nh, *this);

      const std::vector<AbstractGroupDescriptionConstPtr> &__group_descriptions__ = __getGroupDescriptions__();
      for (std::vector<AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); i++){
        if (!setup && (*i)->id == 0) {
          setup = true;
          boost::any n = boost::any(this);
          (*i)->setInitialState(n);
        }
      }
    }

    void __clamp__()
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      const TebLocalPlannerReconfigureConfig &__max__ = __getMax__();
      const TebLocalPlannerReconfigureConfig &__min__ = __getMin__();
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->clamp(*this, __max__, __min__);
    }

    uint32_t __level__(const TebLocalPlannerReconfigureConfig &config) const
    {
      const std::vector<AbstractParamDescriptionConstPtr> &__param_descriptions__ = __getParamDescriptions__();
      uint32_t level = 0;
      for (std::vector<AbstractParamDescriptionConstPtr>::const_iterator i = __param_descriptions__.begin(); i != __param_descriptions__.end(); ++i)
        (*i)->calcLevel(level, config, *this);
      return level;
    }

    static const dynamic_reconfigure::ConfigDescription &__getDescriptionMessage__();
    static const TebLocalPlannerReconfigureConfig &__getDefault__();
    static const TebLocalPlannerReconfigureConfig &__getMax__();
    static const TebLocalPlannerReconfigureConfig &__getMin__();
    static const std::vector<AbstractParamDescriptionConstPtr> &__getParamDescriptions__();
    static const std::vector<AbstractGroupDescriptionConstPtr> &__getGroupDescriptions__();

  private:
    static const TebLocalPlannerReconfigureConfigStatics *__get_statics__();
  };

  template <> // Max and min are ignored for strings.
  inline void TebLocalPlannerReconfigureConfig::ParamDescription<std::string>::clamp(TebLocalPlannerReconfigureConfig &config, const TebLocalPlannerReconfigureConfig &max, const TebLocalPlannerReconfigureConfig &min) const
  {
    (void) config;
    (void) min;
    (void) max;
    return;
  }

  class TebLocalPlannerReconfigureConfigStatics
  {
    friend class TebLocalPlannerReconfigureConfig;

    TebLocalPlannerReconfigureConfigStatics()
    {
TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT, TebLocalPlannerReconfigureConfig> Default("Default", "", 0, 0, true, &TebLocalPlannerReconfigureConfig::groups);
TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::TRAJECTORY, TebLocalPlannerReconfigureConfig::DEFAULT> Trajectory("Trajectory", "tab", 0, 1, true, &TebLocalPlannerReconfigureConfig::DEFAULT::trajectory);
//#line 23 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.teb_autosize = 0;
//#line 23 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.teb_autosize = 1;
//#line 23 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.teb_autosize = 1;
//#line 23 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Trajectory.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("teb_autosize", "bool", 0, "Enable the automatic resizing of the trajectory during optimization (based on the temporal resolution of the trajectory, recommended)", "", &TebLocalPlannerReconfigureConfig::teb_autosize)));
//#line 23 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("teb_autosize", "bool", 0, "Enable the automatic resizing of the trajectory during optimization (based on the temporal resolution of the trajectory, recommended)", "", &TebLocalPlannerReconfigureConfig::teb_autosize)));
//#line 27 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.dt_ref = 0.01;
//#line 27 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.dt_ref = 1.0;
//#line 27 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.dt_ref = 0.3;
//#line 27 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Trajectory.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("dt_ref", "double", 0, "Temporal resolution of the planned trajectory (usually it is set to the magnitude of the 1/control_rate)", "", &TebLocalPlannerReconfigureConfig::dt_ref)));
//#line 27 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("dt_ref", "double", 0, "Temporal resolution of the planned trajectory (usually it is set to the magnitude of the 1/control_rate)", "", &TebLocalPlannerReconfigureConfig::dt_ref)));
//#line 31 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.dt_hysteresis = 0.002;
//#line 31 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.dt_hysteresis = 0.5;
//#line 31 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.dt_hysteresis = 0.1;
//#line 31 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Trajectory.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("dt_hysteresis", "double", 0, "Hysteresis that is utilized for automatic resizing depending on the current temporal resolution (dt): usually 10% of dt_ref", "", &TebLocalPlannerReconfigureConfig::dt_hysteresis)));
//#line 31 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("dt_hysteresis", "double", 0, "Hysteresis that is utilized for automatic resizing depending on the current temporal resolution (dt): usually 10% of dt_ref", "", &TebLocalPlannerReconfigureConfig::dt_hysteresis)));
//#line 35 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.global_plan_overwrite_orientation = 0;
//#line 35 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.global_plan_overwrite_orientation = 1;
//#line 35 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.global_plan_overwrite_orientation = 1;
//#line 35 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Trajectory.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("global_plan_overwrite_orientation", "bool", 0, "Some global planners are not considering the orientation at local subgoals between start and global goal, therefore determine it automatically", "", &TebLocalPlannerReconfigureConfig::global_plan_overwrite_orientation)));
//#line 35 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("global_plan_overwrite_orientation", "bool", 0, "Some global planners are not considering the orientation at local subgoals between start and global goal, therefore determine it automatically", "", &TebLocalPlannerReconfigureConfig::global_plan_overwrite_orientation)));
//#line 39 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.allow_init_with_backwards_motion = 0;
//#line 39 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.allow_init_with_backwards_motion = 1;
//#line 39 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.allow_init_with_backwards_motion = 0;
//#line 39 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Trajectory.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("allow_init_with_backwards_motion", "bool", 0, "If true, the underlying trajectories might be initialized with backwards motions in case the goal is behind the start within the local costmap (this is only recommended if the robot is equipped with rear sensors)", "", &TebLocalPlannerReconfigureConfig::allow_init_with_backwards_motion)));
//#line 39 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("allow_init_with_backwards_motion", "bool", 0, "If true, the underlying trajectories might be initialized with backwards motions in case the goal is behind the start within the local costmap (this is only recommended if the robot is equipped with rear sensors)", "", &TebLocalPlannerReconfigureConfig::allow_init_with_backwards_motion)));
//#line 43 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.max_global_plan_lookahead_dist = 0.0;
//#line 43 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.max_global_plan_lookahead_dist = 50.0;
//#line 43 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.max_global_plan_lookahead_dist = 3.0;
//#line 43 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Trajectory.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("max_global_plan_lookahead_dist", "double", 0, "Specify maximum length (cumulative Euclidean distances) of the subset of the global plan taken into account for optimization [if 0 or negative: disabled; the length is also bounded by the local costmap size]", "", &TebLocalPlannerReconfigureConfig::max_global_plan_lookahead_dist)));
//#line 43 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("max_global_plan_lookahead_dist", "double", 0, "Specify maximum length (cumulative Euclidean distances) of the subset of the global plan taken into account for optimization [if 0 or negative: disabled; the length is also bounded by the local costmap size]", "", &TebLocalPlannerReconfigureConfig::max_global_plan_lookahead_dist)));
//#line 47 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.force_reinit_new_goal_dist = 0.0;
//#line 47 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.force_reinit_new_goal_dist = 10.0;
//#line 47 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.force_reinit_new_goal_dist = 1.0;
//#line 47 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Trajectory.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("force_reinit_new_goal_dist", "double", 0, "Force the planner to reinitialize the trajectory if a previous goal is updated with a seperation of more than the specified value in meters (skip hot-starting)", "", &TebLocalPlannerReconfigureConfig::force_reinit_new_goal_dist)));
//#line 47 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("force_reinit_new_goal_dist", "double", 0, "Force the planner to reinitialize the trajectory if a previous goal is updated with a seperation of more than the specified value in meters (skip hot-starting)", "", &TebLocalPlannerReconfigureConfig::force_reinit_new_goal_dist)));
//#line 51 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.feasibility_check_no_poses = 0;
//#line 51 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.feasibility_check_no_poses = 50;
//#line 51 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.feasibility_check_no_poses = 5;
//#line 51 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Trajectory.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<int>("feasibility_check_no_poses", "int", 0, "Specify up to which pose on the predicted plan the feasibility should be checked each sampling interval", "", &TebLocalPlannerReconfigureConfig::feasibility_check_no_poses)));
//#line 51 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<int>("feasibility_check_no_poses", "int", 0, "Specify up to which pose on the predicted plan the feasibility should be checked each sampling interval", "", &TebLocalPlannerReconfigureConfig::feasibility_check_no_poses)));
//#line 55 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.exact_arc_length = 0;
//#line 55 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.exact_arc_length = 1;
//#line 55 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.exact_arc_length = 0;
//#line 55 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Trajectory.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("exact_arc_length", "bool", 0, "If true, the planner uses the exact arc length in velocity, acceleration and turning rate computations [-> increased cpu time], otherwise the euclidean approximation is used.", "", &TebLocalPlannerReconfigureConfig::exact_arc_length)));
//#line 55 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("exact_arc_length", "bool", 0, "If true, the planner uses the exact arc length in velocity, acceleration and turning rate computations [-> increased cpu time], otherwise the euclidean approximation is used.", "", &TebLocalPlannerReconfigureConfig::exact_arc_length)));
//#line 59 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.publish_feedback = 0;
//#line 59 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.publish_feedback = 1;
//#line 59 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.publish_feedback = 0;
//#line 59 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Trajectory.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("publish_feedback", "bool", 0, "Publish planner feedback containing the full trajectory and a list of active obstacles (should be enabled only for evaluation or debugging purposes)", "", &TebLocalPlannerReconfigureConfig::publish_feedback)));
//#line 59 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("publish_feedback", "bool", 0, "Publish planner feedback containing the full trajectory and a list of active obstacles (should be enabled only for evaluation or debugging purposes)", "", &TebLocalPlannerReconfigureConfig::publish_feedback)));
//#line 63 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.visualize_with_time_as_z_axis_scale = 0.0;
//#line 63 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.visualize_with_time_as_z_axis_scale = 1.0;
//#line 63 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.visualize_with_time_as_z_axis_scale = 0.0;
//#line 63 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Trajectory.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("visualize_with_time_as_z_axis_scale", "double", 0, "If this value is bigger than 0, the trajectory and obstacles are visualized in 3d using the time as the z-axis scaled by this value. Most useful for dynamic obstacles.", "", &TebLocalPlannerReconfigureConfig::visualize_with_time_as_z_axis_scale)));
//#line 63 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("visualize_with_time_as_z_axis_scale", "double", 0, "If this value is bigger than 0, the trajectory and obstacles are visualized in 3d using the time as the z-axis scaled by this value. Most useful for dynamic obstacles.", "", &TebLocalPlannerReconfigureConfig::visualize_with_time_as_z_axis_scale)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Trajectory.convertParams();
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.groups.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::TRAJECTORY, TebLocalPlannerReconfigureConfig::DEFAULT>(Trajectory)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::TRAJECTORY, TebLocalPlannerReconfigureConfig::DEFAULT>(Trajectory)));
TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::VIAPOINTS, TebLocalPlannerReconfigureConfig::DEFAULT> ViaPoints("ViaPoints", "tab", 0, 2, true, &TebLocalPlannerReconfigureConfig::DEFAULT::viapoints);
//#line 70 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.global_plan_viapoint_sep = -0.1;
//#line 70 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.global_plan_viapoint_sep = 5.0;
//#line 70 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.global_plan_viapoint_sep = -0.1;
//#line 70 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      ViaPoints.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("global_plan_viapoint_sep", "double", 0, "Min. separation between each two consecutive via-points extracted from the global plan [if negative: disabled]", "", &TebLocalPlannerReconfigureConfig::global_plan_viapoint_sep)));
//#line 70 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("global_plan_viapoint_sep", "double", 0, "Min. separation between each two consecutive via-points extracted from the global plan [if negative: disabled]", "", &TebLocalPlannerReconfigureConfig::global_plan_viapoint_sep)));
//#line 74 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.via_points_ordered = 0;
//#line 74 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.via_points_ordered = 1;
//#line 74 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.via_points_ordered = 0;
//#line 74 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      ViaPoints.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("via_points_ordered", "bool", 0, "If true, the planner adheres to the order of via-points in the storage container", "", &TebLocalPlannerReconfigureConfig::via_points_ordered)));
//#line 74 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("via_points_ordered", "bool", 0, "If true, the planner adheres to the order of via-points in the storage container", "", &TebLocalPlannerReconfigureConfig::via_points_ordered)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      ViaPoints.convertParams();
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.groups.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::VIAPOINTS, TebLocalPlannerReconfigureConfig::DEFAULT>(ViaPoints)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::VIAPOINTS, TebLocalPlannerReconfigureConfig::DEFAULT>(ViaPoints)));
TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT, TebLocalPlannerReconfigureConfig::DEFAULT> Robot("Robot", "tab", 0, 3, true, &TebLocalPlannerReconfigureConfig::DEFAULT::robot);
//#line 81 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.max_vel_x = 0.01;
//#line 81 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.max_vel_x = 100.0;
//#line 81 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.max_vel_x = 0.4;
//#line 81 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Robot.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("max_vel_x", "double", 0, "Maximum translational velocity of the robot", "", &TebLocalPlannerReconfigureConfig::max_vel_x)));
//#line 81 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("max_vel_x", "double", 0, "Maximum translational velocity of the robot", "", &TebLocalPlannerReconfigureConfig::max_vel_x)));
//#line 85 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.max_vel_x_backwards = 0.01;
//#line 85 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.max_vel_x_backwards = 100.0;
//#line 85 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.max_vel_x_backwards = 0.2;
//#line 85 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Robot.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("max_vel_x_backwards", "double", 0, "Maximum translational velocity of the robot for driving backwards", "", &TebLocalPlannerReconfigureConfig::max_vel_x_backwards)));
//#line 85 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("max_vel_x_backwards", "double", 0, "Maximum translational velocity of the robot for driving backwards", "", &TebLocalPlannerReconfigureConfig::max_vel_x_backwards)));
//#line 89 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.max_vel_theta = 0.01;
//#line 89 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.max_vel_theta = 100.0;
//#line 89 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.max_vel_theta = 0.3;
//#line 89 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Robot.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("max_vel_theta", "double", 0, "Maximum angular velocity of the robot", "", &TebLocalPlannerReconfigureConfig::max_vel_theta)));
//#line 89 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("max_vel_theta", "double", 0, "Maximum angular velocity of the robot", "", &TebLocalPlannerReconfigureConfig::max_vel_theta)));
//#line 93 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.acc_lim_x = 0.01;
//#line 93 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.acc_lim_x = 100.0;
//#line 93 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.acc_lim_x = 0.5;
//#line 93 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Robot.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("acc_lim_x", "double", 0, "Maximum translational acceleration of the robot", "", &TebLocalPlannerReconfigureConfig::acc_lim_x)));
//#line 93 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("acc_lim_x", "double", 0, "Maximum translational acceleration of the robot", "", &TebLocalPlannerReconfigureConfig::acc_lim_x)));
//#line 97 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.acc_lim_theta = 0.01;
//#line 97 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.acc_lim_theta = 100.0;
//#line 97 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.acc_lim_theta = 0.5;
//#line 97 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Robot.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("acc_lim_theta", "double", 0, "Maximum angular acceleration of the robot", "", &TebLocalPlannerReconfigureConfig::acc_lim_theta)));
//#line 97 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("acc_lim_theta", "double", 0, "Maximum angular acceleration of the robot", "", &TebLocalPlannerReconfigureConfig::acc_lim_theta)));
//#line 101 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.is_footprint_dynamic = 0;
//#line 101 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.is_footprint_dynamic = 1;
//#line 101 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.is_footprint_dynamic = 0;
//#line 101 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Robot.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("is_footprint_dynamic", "bool", 0, "If true, updated the footprint before checking trajectory feasibility", "", &TebLocalPlannerReconfigureConfig::is_footprint_dynamic)));
//#line 101 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("is_footprint_dynamic", "bool", 0, "If true, updated the footprint before checking trajectory feasibility", "", &TebLocalPlannerReconfigureConfig::is_footprint_dynamic)));
TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT::CARLIKE, TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT> Carlike("Carlike", "hide", 3, 4, true, &TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT::carlike);
//#line 109 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.min_turning_radius = 0.0;
//#line 109 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.min_turning_radius = 50.0;
//#line 109 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.min_turning_radius = 0.0;
//#line 109 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Carlike.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("min_turning_radius", "double", 0, "Minimum turning radius of a carlike robot (diff-drive robot: zero)", "", &TebLocalPlannerReconfigureConfig::min_turning_radius)));
//#line 109 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("min_turning_radius", "double", 0, "Minimum turning radius of a carlike robot (diff-drive robot: zero)", "", &TebLocalPlannerReconfigureConfig::min_turning_radius)));
//#line 113 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.wheelbase = -10.0;
//#line 113 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.wheelbase = 10.0;
//#line 113 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.wheelbase = 1.0;
//#line 113 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Carlike.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("wheelbase", "double", 0, "The distance between the drive shaft and steering axle (only required for a carlike robot with 'cmd_angle_instead_rotvel' enabled); The value might be negative for back-wheeled robots!", "", &TebLocalPlannerReconfigureConfig::wheelbase)));
//#line 113 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("wheelbase", "double", 0, "The distance between the drive shaft and steering axle (only required for a carlike robot with 'cmd_angle_instead_rotvel' enabled); The value might be negative for back-wheeled robots!", "", &TebLocalPlannerReconfigureConfig::wheelbase)));
//#line 117 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.cmd_angle_instead_rotvel = 0;
//#line 117 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.cmd_angle_instead_rotvel = 1;
//#line 117 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.cmd_angle_instead_rotvel = 0;
//#line 117 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Carlike.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("cmd_angle_instead_rotvel", "bool", 0, "Substitute the rotational velocity in the commanded velocity message by the corresponding steering angle (check 'axles_distance')", "", &TebLocalPlannerReconfigureConfig::cmd_angle_instead_rotvel)));
//#line 117 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("cmd_angle_instead_rotvel", "bool", 0, "Substitute the rotational velocity in the commanded velocity message by the corresponding steering angle (check 'axles_distance')", "", &TebLocalPlannerReconfigureConfig::cmd_angle_instead_rotvel)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Carlike.convertParams();
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Robot.groups.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT::CARLIKE, TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT>(Carlike)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT::CARLIKE, TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT>(Carlike)));
TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT::OMNIDIRECTIONAL, TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT> Omnidirectional("Omnidirectional", "hide", 3, 5, true, &TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT::omnidirectional);
//#line 125 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.max_vel_y = 0.0;
//#line 125 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.max_vel_y = 100.0;
//#line 125 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.max_vel_y = 0.0;
//#line 125 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Omnidirectional.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("max_vel_y", "double", 0, "Maximum strafing velocity of the robot (should be zero for non-holonomic robots!)", "", &TebLocalPlannerReconfigureConfig::max_vel_y)));
//#line 125 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("max_vel_y", "double", 0, "Maximum strafing velocity of the robot (should be zero for non-holonomic robots!)", "", &TebLocalPlannerReconfigureConfig::max_vel_y)));
//#line 129 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.acc_lim_y = 0.01;
//#line 129 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.acc_lim_y = 100.0;
//#line 129 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.acc_lim_y = 0.5;
//#line 129 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Omnidirectional.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("acc_lim_y", "double", 0, "Maximum strafing acceleration of the robot", "", &TebLocalPlannerReconfigureConfig::acc_lim_y)));
//#line 129 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("acc_lim_y", "double", 0, "Maximum strafing acceleration of the robot", "", &TebLocalPlannerReconfigureConfig::acc_lim_y)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Omnidirectional.convertParams();
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Robot.groups.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT::OMNIDIRECTIONAL, TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT>(Omnidirectional)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT::OMNIDIRECTIONAL, TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT>(Omnidirectional)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Robot.convertParams();
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.groups.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT, TebLocalPlannerReconfigureConfig::DEFAULT>(Robot)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::ROBOT, TebLocalPlannerReconfigureConfig::DEFAULT>(Robot)));
TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::GOALTOLERANCE, TebLocalPlannerReconfigureConfig::DEFAULT> GoalTolerance("GoalTolerance", "tab", 0, 6, true, &TebLocalPlannerReconfigureConfig::DEFAULT::goaltolerance);
//#line 136 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.xy_goal_tolerance = 0.001;
//#line 136 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.xy_goal_tolerance = 10.0;
//#line 136 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.xy_goal_tolerance = 0.2;
//#line 136 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      GoalTolerance.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("xy_goal_tolerance", "double", 0, "Allowed final euclidean distance to the goal position", "", &TebLocalPlannerReconfigureConfig::xy_goal_tolerance)));
//#line 136 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("xy_goal_tolerance", "double", 0, "Allowed final euclidean distance to the goal position", "", &TebLocalPlannerReconfigureConfig::xy_goal_tolerance)));
//#line 140 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.yaw_goal_tolerance = 0.001;
//#line 140 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.yaw_goal_tolerance = 3.2;
//#line 140 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.yaw_goal_tolerance = 0.1;
//#line 140 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      GoalTolerance.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("yaw_goal_tolerance", "double", 0, "Allowed final orientation error to the goal orientation", "", &TebLocalPlannerReconfigureConfig::yaw_goal_tolerance)));
//#line 140 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("yaw_goal_tolerance", "double", 0, "Allowed final orientation error to the goal orientation", "", &TebLocalPlannerReconfigureConfig::yaw_goal_tolerance)));
//#line 144 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.free_goal_vel = 0;
//#line 144 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.free_goal_vel = 1;
//#line 144 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.free_goal_vel = 0;
//#line 144 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      GoalTolerance.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("free_goal_vel", "bool", 0, "Allow the robot's velocity to be nonzero for planning purposes (the robot can arrive at the goal with max speed)", "", &TebLocalPlannerReconfigureConfig::free_goal_vel)));
//#line 144 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("free_goal_vel", "bool", 0, "Allow the robot's velocity to be nonzero for planning purposes (the robot can arrive at the goal with max speed)", "", &TebLocalPlannerReconfigureConfig::free_goal_vel)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      GoalTolerance.convertParams();
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.groups.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::GOALTOLERANCE, TebLocalPlannerReconfigureConfig::DEFAULT>(GoalTolerance)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::GOALTOLERANCE, TebLocalPlannerReconfigureConfig::DEFAULT>(GoalTolerance)));
TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::OBSTACLES, TebLocalPlannerReconfigureConfig::DEFAULT> Obstacles("Obstacles", "tab", 0, 7, true, &TebLocalPlannerReconfigureConfig::DEFAULT::obstacles);
//#line 151 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.min_obstacle_dist = 0.0;
//#line 151 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.min_obstacle_dist = 10.0;
//#line 151 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.min_obstacle_dist = 0.5;
//#line 151 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Obstacles.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("min_obstacle_dist", "double", 0, "Minimum desired separation from obstacles", "", &TebLocalPlannerReconfigureConfig::min_obstacle_dist)));
//#line 151 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("min_obstacle_dist", "double", 0, "Minimum desired separation from obstacles", "", &TebLocalPlannerReconfigureConfig::min_obstacle_dist)));
//#line 155 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.inflation_dist = 0.0;
//#line 155 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.inflation_dist = 15.0;
//#line 155 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.inflation_dist = 0.6;
//#line 155 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Obstacles.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("inflation_dist", "double", 0, "Buffer zone around obstacles with non-zero penalty costs (should be larger than min_obstacle_dist in order to take effect)", "", &TebLocalPlannerReconfigureConfig::inflation_dist)));
//#line 155 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("inflation_dist", "double", 0, "Buffer zone around obstacles with non-zero penalty costs (should be larger than min_obstacle_dist in order to take effect)", "", &TebLocalPlannerReconfigureConfig::inflation_dist)));
//#line 159 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.dynamic_obstacle_inflation_dist = 0.0;
//#line 159 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.dynamic_obstacle_inflation_dist = 15.0;
//#line 159 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.dynamic_obstacle_inflation_dist = 0.6;
//#line 159 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Obstacles.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("dynamic_obstacle_inflation_dist", "double", 0, "Buffer zone around predicted locations of dynamic obstacles with non-zero penalty costs (should be larger than min_obstacle_dist in order to take effect)", "", &TebLocalPlannerReconfigureConfig::dynamic_obstacle_inflation_dist)));
//#line 159 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("dynamic_obstacle_inflation_dist", "double", 0, "Buffer zone around predicted locations of dynamic obstacles with non-zero penalty costs (should be larger than min_obstacle_dist in order to take effect)", "", &TebLocalPlannerReconfigureConfig::dynamic_obstacle_inflation_dist)));
//#line 163 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.include_dynamic_obstacles = 0;
//#line 163 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.include_dynamic_obstacles = 1;
//#line 163 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.include_dynamic_obstacles = 0;
//#line 163 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Obstacles.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("include_dynamic_obstacles", "bool", 0, "Specify whether the movement of dynamic obstacles should be predicted by a constant velocity model (this also changes the homotopy class search). If false, all obstacles are considered to be static.", "", &TebLocalPlannerReconfigureConfig::include_dynamic_obstacles)));
//#line 163 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("include_dynamic_obstacles", "bool", 0, "Specify whether the movement of dynamic obstacles should be predicted by a constant velocity model (this also changes the homotopy class search). If false, all obstacles are considered to be static.", "", &TebLocalPlannerReconfigureConfig::include_dynamic_obstacles)));
//#line 167 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.include_costmap_obstacles = 0;
//#line 167 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.include_costmap_obstacles = 1;
//#line 167 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.include_costmap_obstacles = 1;
//#line 167 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Obstacles.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("include_costmap_obstacles", "bool", 0, "Specify whether the obstacles in the costmap should be taken into account directly (this is necessary if no seperate clustering and detection is implemented)", "", &TebLocalPlannerReconfigureConfig::include_costmap_obstacles)));
//#line 167 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("include_costmap_obstacles", "bool", 0, "Specify whether the obstacles in the costmap should be taken into account directly (this is necessary if no seperate clustering and detection is implemented)", "", &TebLocalPlannerReconfigureConfig::include_costmap_obstacles)));
//#line 171 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.legacy_obstacle_association = 0;
//#line 171 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.legacy_obstacle_association = 1;
//#line 171 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.legacy_obstacle_association = 0;
//#line 171 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Obstacles.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("legacy_obstacle_association", "bool", 0, "If true, the old association strategy is used (for each obstacle, find the nearest TEB pose), otherwise the new one (for each teb pose, find only 'relevant' obstacles).", "", &TebLocalPlannerReconfigureConfig::legacy_obstacle_association)));
//#line 171 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("legacy_obstacle_association", "bool", 0, "If true, the old association strategy is used (for each obstacle, find the nearest TEB pose), otherwise the new one (for each teb pose, find only 'relevant' obstacles).", "", &TebLocalPlannerReconfigureConfig::legacy_obstacle_association)));
//#line 175 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.obstacle_association_force_inclusion_factor = 0.0;
//#line 175 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.obstacle_association_force_inclusion_factor = 100.0;
//#line 175 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.obstacle_association_force_inclusion_factor = 1.5;
//#line 175 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Obstacles.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("obstacle_association_force_inclusion_factor", "double", 0, "The non-legacy obstacle association technique tries to connect only relevant obstacles with the discretized trajectory during optimization, all obstacles within a specifed distance are forced to be included (as a multiple of min_obstacle_dist), e.g. choose 2.0 in order to consider obstacles within a radius of 2.0*min_obstacle_dist.", "", &TebLocalPlannerReconfigureConfig::obstacle_association_force_inclusion_factor)));
//#line 175 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("obstacle_association_force_inclusion_factor", "double", 0, "The non-legacy obstacle association technique tries to connect only relevant obstacles with the discretized trajectory during optimization, all obstacles within a specifed distance are forced to be included (as a multiple of min_obstacle_dist), e.g. choose 2.0 in order to consider obstacles within a radius of 2.0*min_obstacle_dist.", "", &TebLocalPlannerReconfigureConfig::obstacle_association_force_inclusion_factor)));
//#line 179 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.obstacle_association_cutoff_factor = 1.0;
//#line 179 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.obstacle_association_cutoff_factor = 100.0;
//#line 179 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.obstacle_association_cutoff_factor = 5.0;
//#line 179 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Obstacles.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("obstacle_association_cutoff_factor", "double", 0, "See obstacle_association_force_inclusion_factor, but beyond a multiple of [value]*min_obstacle_dist all obstacles are ignored during optimization. obstacle_association_force_inclusion_factor is processed first.", "", &TebLocalPlannerReconfigureConfig::obstacle_association_cutoff_factor)));
//#line 179 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("obstacle_association_cutoff_factor", "double", 0, "See obstacle_association_force_inclusion_factor, but beyond a multiple of [value]*min_obstacle_dist all obstacles are ignored during optimization. obstacle_association_force_inclusion_factor is processed first.", "", &TebLocalPlannerReconfigureConfig::obstacle_association_cutoff_factor)));
//#line 183 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.costmap_obstacles_behind_robot_dist = 0.0;
//#line 183 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.costmap_obstacles_behind_robot_dist = 20.0;
//#line 183 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.costmap_obstacles_behind_robot_dist = 1.5;
//#line 183 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Obstacles.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("costmap_obstacles_behind_robot_dist", "double", 0, "Limit the occupied local costmap obstacles taken into account for planning behind the robot (specify distance in meters)", "", &TebLocalPlannerReconfigureConfig::costmap_obstacles_behind_robot_dist)));
//#line 183 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("costmap_obstacles_behind_robot_dist", "double", 0, "Limit the occupied local costmap obstacles taken into account for planning behind the robot (specify distance in meters)", "", &TebLocalPlannerReconfigureConfig::costmap_obstacles_behind_robot_dist)));
//#line 187 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.obstacle_poses_affected = 0;
//#line 187 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.obstacle_poses_affected = 200;
//#line 187 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.obstacle_poses_affected = 30;
//#line 187 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Obstacles.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<int>("obstacle_poses_affected", "int", 0, "The obstacle position is attached to the closest pose on the trajectory to reduce computational effort, but take a number of neighbors into account as well", "", &TebLocalPlannerReconfigureConfig::obstacle_poses_affected)));
//#line 187 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<int>("obstacle_poses_affected", "int", 0, "The obstacle position is attached to the closest pose on the trajectory to reduce computational effort, but take a number of neighbors into account as well", "", &TebLocalPlannerReconfigureConfig::obstacle_poses_affected)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Obstacles.convertParams();
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.groups.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::OBSTACLES, TebLocalPlannerReconfigureConfig::DEFAULT>(Obstacles)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::OBSTACLES, TebLocalPlannerReconfigureConfig::DEFAULT>(Obstacles)));
TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::OPTIMIZATION, TebLocalPlannerReconfigureConfig::DEFAULT> Optimization("Optimization", "tab", 0, 8, true, &TebLocalPlannerReconfigureConfig::DEFAULT::optimization);
//#line 195 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.no_inner_iterations = 1;
//#line 195 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.no_inner_iterations = 100;
//#line 195 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.no_inner_iterations = 5;
//#line 195 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<int>("no_inner_iterations", "int", 0, "Number of solver iterations called in each outerloop iteration", "", &TebLocalPlannerReconfigureConfig::no_inner_iterations)));
//#line 195 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<int>("no_inner_iterations", "int", 0, "Number of solver iterations called in each outerloop iteration", "", &TebLocalPlannerReconfigureConfig::no_inner_iterations)));
//#line 199 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.no_outer_iterations = 1;
//#line 199 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.no_outer_iterations = 100;
//#line 199 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.no_outer_iterations = 4;
//#line 199 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<int>("no_outer_iterations", "int", 0, "Each outerloop iteration automatically resizes the trajectory and invokes the internal optimizer with no_inner_iterations", "", &TebLocalPlannerReconfigureConfig::no_outer_iterations)));
//#line 199 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<int>("no_outer_iterations", "int", 0, "Each outerloop iteration automatically resizes the trajectory and invokes the internal optimizer with no_inner_iterations", "", &TebLocalPlannerReconfigureConfig::no_outer_iterations)));
//#line 203 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.optimization_activate = 0;
//#line 203 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.optimization_activate = 1;
//#line 203 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.optimization_activate = 1;
//#line 203 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("optimization_activate", "bool", 0, "Activate the optimization", "", &TebLocalPlannerReconfigureConfig::optimization_activate)));
//#line 203 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("optimization_activate", "bool", 0, "Activate the optimization", "", &TebLocalPlannerReconfigureConfig::optimization_activate)));
//#line 207 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.optimization_verbose = 0;
//#line 207 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.optimization_verbose = 1;
//#line 207 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.optimization_verbose = 0;
//#line 207 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("optimization_verbose", "bool", 0, "Print verbose information", "", &TebLocalPlannerReconfigureConfig::optimization_verbose)));
//#line 207 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("optimization_verbose", "bool", 0, "Print verbose information", "", &TebLocalPlannerReconfigureConfig::optimization_verbose)));
//#line 211 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.penalty_epsilon = 0.0;
//#line 211 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.penalty_epsilon = 1.0;
//#line 211 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.penalty_epsilon = 0.1;
//#line 211 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("penalty_epsilon", "double", 0, "Add a small safty margin to penalty functions for hard-constraint approximations", "", &TebLocalPlannerReconfigureConfig::penalty_epsilon)));
//#line 211 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("penalty_epsilon", "double", 0, "Add a small safty margin to penalty functions for hard-constraint approximations", "", &TebLocalPlannerReconfigureConfig::penalty_epsilon)));
//#line 215 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_max_vel_x = 0.0;
//#line 215 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_max_vel_x = 1000.0;
//#line 215 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_max_vel_x = 2.0;
//#line 215 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_max_vel_x", "double", 0, "Optimization weight for satisfying the maximum allowed translational velocity", "", &TebLocalPlannerReconfigureConfig::weight_max_vel_x)));
//#line 215 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_max_vel_x", "double", 0, "Optimization weight for satisfying the maximum allowed translational velocity", "", &TebLocalPlannerReconfigureConfig::weight_max_vel_x)));
//#line 219 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_max_vel_y = 0.0;
//#line 219 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_max_vel_y = 1000.0;
//#line 219 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_max_vel_y = 2.0;
//#line 219 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_max_vel_y", "double", 0, "Optimization weight for satisfying the maximum allowed strafing velocity (in use only for holonomic robots)", "", &TebLocalPlannerReconfigureConfig::weight_max_vel_y)));
//#line 219 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_max_vel_y", "double", 0, "Optimization weight for satisfying the maximum allowed strafing velocity (in use only for holonomic robots)", "", &TebLocalPlannerReconfigureConfig::weight_max_vel_y)));
//#line 223 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_max_vel_theta = 0.0;
//#line 223 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_max_vel_theta = 1000.0;
//#line 223 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_max_vel_theta = 1.0;
//#line 223 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_max_vel_theta", "double", 0, "Optimization weight for satisfying the maximum allowed angular velocity", "", &TebLocalPlannerReconfigureConfig::weight_max_vel_theta)));
//#line 223 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_max_vel_theta", "double", 0, "Optimization weight for satisfying the maximum allowed angular velocity", "", &TebLocalPlannerReconfigureConfig::weight_max_vel_theta)));
//#line 227 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_acc_lim_x = 0.0;
//#line 227 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_acc_lim_x = 1000.0;
//#line 227 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_acc_lim_x = 1.0;
//#line 227 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_acc_lim_x", "double", 0, "Optimization weight for satisfying the maximum allowed translational acceleration", "", &TebLocalPlannerReconfigureConfig::weight_acc_lim_x)));
//#line 227 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_acc_lim_x", "double", 0, "Optimization weight for satisfying the maximum allowed translational acceleration", "", &TebLocalPlannerReconfigureConfig::weight_acc_lim_x)));
//#line 231 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_acc_lim_y = 0.0;
//#line 231 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_acc_lim_y = 1000.0;
//#line 231 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_acc_lim_y = 1.0;
//#line 231 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_acc_lim_y", "double", 0, "Optimization weight for satisfying the maximum allowed strafing acceleration (in use only for holonomic robots)", "", &TebLocalPlannerReconfigureConfig::weight_acc_lim_y)));
//#line 231 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_acc_lim_y", "double", 0, "Optimization weight for satisfying the maximum allowed strafing acceleration (in use only for holonomic robots)", "", &TebLocalPlannerReconfigureConfig::weight_acc_lim_y)));
//#line 235 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_acc_lim_theta = 0.0;
//#line 235 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_acc_lim_theta = 1000.0;
//#line 235 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_acc_lim_theta = 1.0;
//#line 235 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_acc_lim_theta", "double", 0, "Optimization weight for satisfying the maximum allowed angular acceleration", "", &TebLocalPlannerReconfigureConfig::weight_acc_lim_theta)));
//#line 235 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_acc_lim_theta", "double", 0, "Optimization weight for satisfying the maximum allowed angular acceleration", "", &TebLocalPlannerReconfigureConfig::weight_acc_lim_theta)));
//#line 239 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_kinematics_nh = 0.0;
//#line 239 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_kinematics_nh = 10000.0;
//#line 239 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_kinematics_nh = 1000.0;
//#line 239 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_kinematics_nh", "double", 0, "Optimization weight for satisfying the non-holonomic kinematics", "", &TebLocalPlannerReconfigureConfig::weight_kinematics_nh)));
//#line 239 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_kinematics_nh", "double", 0, "Optimization weight for satisfying the non-holonomic kinematics", "", &TebLocalPlannerReconfigureConfig::weight_kinematics_nh)));
//#line 243 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_kinematics_forward_drive = 0.0;
//#line 243 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_kinematics_forward_drive = 1000.0;
//#line 243 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_kinematics_forward_drive = 1.0;
//#line 243 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_kinematics_forward_drive", "double", 0, "Optimization weight for forcing the robot to choose only forward directions (positive transl. velocities, only diffdrive robot)", "", &TebLocalPlannerReconfigureConfig::weight_kinematics_forward_drive)));
//#line 243 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_kinematics_forward_drive", "double", 0, "Optimization weight for forcing the robot to choose only forward directions (positive transl. velocities, only diffdrive robot)", "", &TebLocalPlannerReconfigureConfig::weight_kinematics_forward_drive)));
//#line 247 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_kinematics_turning_radius = 0.0;
//#line 247 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_kinematics_turning_radius = 1000.0;
//#line 247 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_kinematics_turning_radius = 1.0;
//#line 247 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_kinematics_turning_radius", "double", 0, "Optimization weight for enforcing a minimum turning radius (carlike robots)", "", &TebLocalPlannerReconfigureConfig::weight_kinematics_turning_radius)));
//#line 247 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_kinematics_turning_radius", "double", 0, "Optimization weight for enforcing a minimum turning radius (carlike robots)", "", &TebLocalPlannerReconfigureConfig::weight_kinematics_turning_radius)));
//#line 251 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_optimaltime = 0.0;
//#line 251 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_optimaltime = 1000.0;
//#line 251 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_optimaltime = 1.0;
//#line 251 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_optimaltime", "double", 0, "Optimization weight for contracting the trajectory w.r.t transition time", "", &TebLocalPlannerReconfigureConfig::weight_optimaltime)));
//#line 251 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_optimaltime", "double", 0, "Optimization weight for contracting the trajectory w.r.t transition time", "", &TebLocalPlannerReconfigureConfig::weight_optimaltime)));
//#line 255 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_obstacle = 0.0;
//#line 255 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_obstacle = 1000.0;
//#line 255 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_obstacle = 50.0;
//#line 255 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_obstacle", "double", 0, "Optimization weight for satisfying a minimum seperation from obstacles", "", &TebLocalPlannerReconfigureConfig::weight_obstacle)));
//#line 255 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_obstacle", "double", 0, "Optimization weight for satisfying a minimum seperation from obstacles", "", &TebLocalPlannerReconfigureConfig::weight_obstacle)));
//#line 259 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_inflation = 0.0;
//#line 259 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_inflation = 10.0;
//#line 259 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_inflation = 0.1;
//#line 259 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_inflation", "double", 0, "Optimization weight for the inflation penalty (should be small)", "", &TebLocalPlannerReconfigureConfig::weight_inflation)));
//#line 259 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_inflation", "double", 0, "Optimization weight for the inflation penalty (should be small)", "", &TebLocalPlannerReconfigureConfig::weight_inflation)));
//#line 263 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_dynamic_obstacle = 0.0;
//#line 263 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_dynamic_obstacle = 1000.0;
//#line 263 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_dynamic_obstacle = 50.0;
//#line 263 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_dynamic_obstacle", "double", 0, "Optimization weight for satisfying a minimum seperation from dynamic obstacles", "", &TebLocalPlannerReconfigureConfig::weight_dynamic_obstacle)));
//#line 263 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_dynamic_obstacle", "double", 0, "Optimization weight for satisfying a minimum seperation from dynamic obstacles", "", &TebLocalPlannerReconfigureConfig::weight_dynamic_obstacle)));
//#line 267 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_dynamic_obstacle_inflation = 0.0;
//#line 267 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_dynamic_obstacle_inflation = 10.0;
//#line 267 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_dynamic_obstacle_inflation = 0.1;
//#line 267 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_dynamic_obstacle_inflation", "double", 0, "Optimization weight for the inflation penalty of dynamic obstacles (should be small)", "", &TebLocalPlannerReconfigureConfig::weight_dynamic_obstacle_inflation)));
//#line 267 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_dynamic_obstacle_inflation", "double", 0, "Optimization weight for the inflation penalty of dynamic obstacles (should be small)", "", &TebLocalPlannerReconfigureConfig::weight_dynamic_obstacle_inflation)));
//#line 271 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_viapoint = 0.0;
//#line 271 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_viapoint = 1000.0;
//#line 271 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_viapoint = 1.0;
//#line 271 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_viapoint", "double", 0, "Optimization weight for minimizing the distance to via-points", "", &TebLocalPlannerReconfigureConfig::weight_viapoint)));
//#line 271 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_viapoint", "double", 0, "Optimization weight for minimizing the distance to via-points", "", &TebLocalPlannerReconfigureConfig::weight_viapoint)));
//#line 275 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.weight_adapt_factor = 1.0;
//#line 275 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.weight_adapt_factor = 100.0;
//#line 275 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.weight_adapt_factor = 2.0;
//#line 275 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Optimization.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_adapt_factor", "double", 0, "Some special weights (currently 'weight_obstacle') are repeatedly scaled by this factor in each outer TEB iteration (weight_new: weight_old * factor); Increasing weights iteratively instead of setting a huge value a-priori leads to better numerical conditions of the underlying optimization problem.", "", &TebLocalPlannerReconfigureConfig::weight_adapt_factor)));
//#line 275 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("weight_adapt_factor", "double", 0, "Some special weights (currently 'weight_obstacle') are repeatedly scaled by this factor in each outer TEB iteration (weight_new: weight_old * factor); Increasing weights iteratively instead of setting a huge value a-priori leads to better numerical conditions of the underlying optimization problem.", "", &TebLocalPlannerReconfigureConfig::weight_adapt_factor)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Optimization.convertParams();
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.groups.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::OPTIMIZATION, TebLocalPlannerReconfigureConfig::DEFAULT>(Optimization)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::OPTIMIZATION, TebLocalPlannerReconfigureConfig::DEFAULT>(Optimization)));
TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::HCPLANNING, TebLocalPlannerReconfigureConfig::DEFAULT> HCPlanning("HCPlanning", "tab", 0, 9, true, &TebLocalPlannerReconfigureConfig::DEFAULT::hcplanning);
//#line 284 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.enable_multithreading = 0;
//#line 284 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.enable_multithreading = 1;
//#line 284 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.enable_multithreading = 1;
//#line 284 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("enable_multithreading", "bool", 0, "Activate multiple threading for planning multiple trajectories in parallel", "", &TebLocalPlannerReconfigureConfig::enable_multithreading)));
//#line 284 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("enable_multithreading", "bool", 0, "Activate multiple threading for planning multiple trajectories in parallel", "", &TebLocalPlannerReconfigureConfig::enable_multithreading)));
//#line 288 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.max_number_classes = 1;
//#line 288 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.max_number_classes = 100;
//#line 288 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.max_number_classes = 5;
//#line 288 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<int>("max_number_classes", "int", 0, "Specify the maximum number of allowed alternative homotopy classes (limits computational effort)", "", &TebLocalPlannerReconfigureConfig::max_number_classes)));
//#line 288 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<int>("max_number_classes", "int", 0, "Specify the maximum number of allowed alternative homotopy classes (limits computational effort)", "", &TebLocalPlannerReconfigureConfig::max_number_classes)));
//#line 292 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.selection_cost_hysteresis = 0.0;
//#line 292 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.selection_cost_hysteresis = 2.0;
//#line 292 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.selection_cost_hysteresis = 1.0;
//#line 292 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("selection_cost_hysteresis", "double", 0, "Specify how much trajectory cost must a new candidate have w.r.t. a previously selected trajectory in order to be selected (selection if new_cost < old_cost*factor)", "", &TebLocalPlannerReconfigureConfig::selection_cost_hysteresis)));
//#line 292 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("selection_cost_hysteresis", "double", 0, "Specify how much trajectory cost must a new candidate have w.r.t. a previously selected trajectory in order to be selected (selection if new_cost < old_cost*factor)", "", &TebLocalPlannerReconfigureConfig::selection_cost_hysteresis)));
//#line 297 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.selection_prefer_initial_plan = 0.0;
//#line 297 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.selection_prefer_initial_plan = 1.0;
//#line 297 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.selection_prefer_initial_plan = 0.95;
//#line 297 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("selection_prefer_initial_plan", "double", 0, "Specify a cost reduction in the interval (0,1) for the trajectory in the equivalence class of the initial plan.)", "", &TebLocalPlannerReconfigureConfig::selection_prefer_initial_plan)));
//#line 297 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("selection_prefer_initial_plan", "double", 0, "Specify a cost reduction in the interval (0,1) for the trajectory in the equivalence class of the initial plan.)", "", &TebLocalPlannerReconfigureConfig::selection_prefer_initial_plan)));
//#line 301 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.selection_obst_cost_scale = 0.0;
//#line 301 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.selection_obst_cost_scale = 1000.0;
//#line 301 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.selection_obst_cost_scale = 100.0;
//#line 301 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("selection_obst_cost_scale", "double", 0, "Extra scaling of obstacle cost terms just for selecting the 'best' candidate (new_obst_cost: obst_cost*factor)", "", &TebLocalPlannerReconfigureConfig::selection_obst_cost_scale)));
//#line 301 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("selection_obst_cost_scale", "double", 0, "Extra scaling of obstacle cost terms just for selecting the 'best' candidate (new_obst_cost: obst_cost*factor)", "", &TebLocalPlannerReconfigureConfig::selection_obst_cost_scale)));
//#line 305 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.selection_viapoint_cost_scale = 0.0;
//#line 305 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.selection_viapoint_cost_scale = 100.0;
//#line 305 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.selection_viapoint_cost_scale = 1.0;
//#line 305 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("selection_viapoint_cost_scale", "double", 0, "Extra scaling of via-point cost terms just for selecting the 'best' candidate. (new_viapt_cost: viapt_cost*factor)", "", &TebLocalPlannerReconfigureConfig::selection_viapoint_cost_scale)));
//#line 305 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("selection_viapoint_cost_scale", "double", 0, "Extra scaling of via-point cost terms just for selecting the 'best' candidate. (new_viapt_cost: viapt_cost*factor)", "", &TebLocalPlannerReconfigureConfig::selection_viapoint_cost_scale)));
//#line 309 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.selection_alternative_time_cost = 0;
//#line 309 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.selection_alternative_time_cost = 1;
//#line 309 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.selection_alternative_time_cost = 0;
//#line 309 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("selection_alternative_time_cost", "bool", 0, "If true, time cost is replaced by the total transition time.", "", &TebLocalPlannerReconfigureConfig::selection_alternative_time_cost)));
//#line 309 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("selection_alternative_time_cost", "bool", 0, "If true, time cost is replaced by the total transition time.", "", &TebLocalPlannerReconfigureConfig::selection_alternative_time_cost)));
//#line 313 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.switching_blocking_period = 0.0;
//#line 313 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.switching_blocking_period = 60.0;
//#line 313 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.switching_blocking_period = 0.0;
//#line 313 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("switching_blocking_period", "double", 0, "Specify a time duration in seconds that needs to be expired before a switch to new equivalence class is allowed", "", &TebLocalPlannerReconfigureConfig::switching_blocking_period)));
//#line 313 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("switching_blocking_period", "double", 0, "Specify a time duration in seconds that needs to be expired before a switch to new equivalence class is allowed", "", &TebLocalPlannerReconfigureConfig::switching_blocking_period)));
//#line 317 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.roadmap_graph_no_samples = 1;
//#line 317 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.roadmap_graph_no_samples = 100;
//#line 317 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.roadmap_graph_no_samples = 15;
//#line 317 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<int>("roadmap_graph_no_samples", "int", 0, "Specify the number of samples generated for creating the roadmap graph, if simple_exploration is turend off", "", &TebLocalPlannerReconfigureConfig::roadmap_graph_no_samples)));
//#line 317 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<int>("roadmap_graph_no_samples", "int", 0, "Specify the number of samples generated for creating the roadmap graph, if simple_exploration is turend off", "", &TebLocalPlannerReconfigureConfig::roadmap_graph_no_samples)));
//#line 321 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.roadmap_graph_area_width = 0.1;
//#line 321 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.roadmap_graph_area_width = 20.0;
//#line 321 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.roadmap_graph_area_width = 5.0;
//#line 321 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("roadmap_graph_area_width", "double", 0, "Specify the width of the area in which sampled will be generated between start and goal [m] (the height equals the start-goal distance)", "", &TebLocalPlannerReconfigureConfig::roadmap_graph_area_width)));
//#line 321 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("roadmap_graph_area_width", "double", 0, "Specify the width of the area in which sampled will be generated between start and goal [m] (the height equals the start-goal distance)", "", &TebLocalPlannerReconfigureConfig::roadmap_graph_area_width)));
//#line 325 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.roadmap_graph_area_length_scale = 0.5;
//#line 325 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.roadmap_graph_area_length_scale = 2.0;
//#line 325 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.roadmap_graph_area_length_scale = 1.0;
//#line 325 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("roadmap_graph_area_length_scale", "double", 0, "The length of the rectangular region is determined by the distance between start and goal. This parameter further scales the distance such that the geometric center remains equal!)", "", &TebLocalPlannerReconfigureConfig::roadmap_graph_area_length_scale)));
//#line 325 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("roadmap_graph_area_length_scale", "double", 0, "The length of the rectangular region is determined by the distance between start and goal. This parameter further scales the distance such that the geometric center remains equal!)", "", &TebLocalPlannerReconfigureConfig::roadmap_graph_area_length_scale)));
//#line 329 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.h_signature_prescaler = 0.2;
//#line 329 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.h_signature_prescaler = 1.0;
//#line 329 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.h_signature_prescaler = 1.0;
//#line 329 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("h_signature_prescaler", "double", 0, "Scale number of obstacle value in order to allow huge number of obstacles. Do not choose it extremly low, otherwise obstacles cannot be distinguished from each other (0.2<H<=1)", "", &TebLocalPlannerReconfigureConfig::h_signature_prescaler)));
//#line 329 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("h_signature_prescaler", "double", 0, "Scale number of obstacle value in order to allow huge number of obstacles. Do not choose it extremly low, otherwise obstacles cannot be distinguished from each other (0.2<H<=1)", "", &TebLocalPlannerReconfigureConfig::h_signature_prescaler)));
//#line 333 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.h_signature_threshold = 0.0;
//#line 333 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.h_signature_threshold = 1.0;
//#line 333 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.h_signature_threshold = 0.1;
//#line 333 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("h_signature_threshold", "double", 0, "Two h-signuteres are assumed to be equal, if both the difference of real parts and complex parts are below the specified threshold", "", &TebLocalPlannerReconfigureConfig::h_signature_threshold)));
//#line 333 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("h_signature_threshold", "double", 0, "Two h-signuteres are assumed to be equal, if both the difference of real parts and complex parts are below the specified threshold", "", &TebLocalPlannerReconfigureConfig::h_signature_threshold)));
//#line 337 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.obstacle_heading_threshold = 0.0;
//#line 337 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.obstacle_heading_threshold = 1.0;
//#line 337 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.obstacle_heading_threshold = 0.45;
//#line 337 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("obstacle_heading_threshold", "double", 0, "Specify the value of the normalized scalar product between obstacle heading and goal heading in order to take them (obstacles) into account for exploration)", "", &TebLocalPlannerReconfigureConfig::obstacle_heading_threshold)));
//#line 337 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<double>("obstacle_heading_threshold", "double", 0, "Specify the value of the normalized scalar product between obstacle heading and goal heading in order to take them (obstacles) into account for exploration)", "", &TebLocalPlannerReconfigureConfig::obstacle_heading_threshold)));
//#line 341 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.viapoints_all_candidates = 0;
//#line 341 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.viapoints_all_candidates = 1;
//#line 341 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.viapoints_all_candidates = 1;
//#line 341 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("viapoints_all_candidates", "bool", 0, "If true, all trajectories of different topologies are attached to the set of via-points, otherwise only the trajectory sharing the same one as the initial/global plan is attached (no effect in test_optim_node).", "", &TebLocalPlannerReconfigureConfig::viapoints_all_candidates)));
//#line 341 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("viapoints_all_candidates", "bool", 0, "If true, all trajectories of different topologies are attached to the set of via-points, otherwise only the trajectory sharing the same one as the initial/global plan is attached (no effect in test_optim_node).", "", &TebLocalPlannerReconfigureConfig::viapoints_all_candidates)));
//#line 345 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.visualize_hc_graph = 0;
//#line 345 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.visualize_hc_graph = 1;
//#line 345 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.visualize_hc_graph = 0;
//#line 345 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      HCPlanning.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("visualize_hc_graph", "bool", 0, "Visualize the graph that is created for exploring new homotopy classes", "", &TebLocalPlannerReconfigureConfig::visualize_hc_graph)));
//#line 345 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("visualize_hc_graph", "bool", 0, "Visualize the graph that is created for exploring new homotopy classes", "", &TebLocalPlannerReconfigureConfig::visualize_hc_graph)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      HCPlanning.convertParams();
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.groups.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::HCPLANNING, TebLocalPlannerReconfigureConfig::DEFAULT>(HCPlanning)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::HCPLANNING, TebLocalPlannerReconfigureConfig::DEFAULT>(HCPlanning)));
TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::RECOVERY, TebLocalPlannerReconfigureConfig::DEFAULT> Recovery("Recovery", "tab", 0, 10, true, &TebLocalPlannerReconfigureConfig::DEFAULT::recovery);
//#line 353 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.shrink_horizon_backup = 0;
//#line 353 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.shrink_horizon_backup = 1;
//#line 353 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.shrink_horizon_backup = 1;
//#line 353 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Recovery.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("shrink_horizon_backup", "bool", 0, "Allows the planner to shrink the horizon temporary (50%) in case of automatically detected issues.", "", &TebLocalPlannerReconfigureConfig::shrink_horizon_backup)));
//#line 353 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("shrink_horizon_backup", "bool", 0, "Allows the planner to shrink the horizon temporary (50%) in case of automatically detected issues.", "", &TebLocalPlannerReconfigureConfig::shrink_horizon_backup)));
//#line 357 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __min__.oscillation_recovery = 0;
//#line 357 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __max__.oscillation_recovery = 1;
//#line 357 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __default__.oscillation_recovery = 1;
//#line 357 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      Recovery.abstract_parameters.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("oscillation_recovery", "bool", 0, "Try to detect and resolve oscillations between multiple solutions in the same equivalence class (robot frequently switches between left/right/forward/backwards).", "", &TebLocalPlannerReconfigureConfig::oscillation_recovery)));
//#line 357 "/home/nvidia/git/repos/ros/catkin_ws/src/teb_local_planner/cfg/TebLocalPlannerReconfigure.cfg"
      __param_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::ParamDescription<bool>("oscillation_recovery", "bool", 0, "Try to detect and resolve oscillations between multiple solutions in the same equivalence class (robot frequently switches between left/right/forward/backwards).", "", &TebLocalPlannerReconfigureConfig::oscillation_recovery)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Recovery.convertParams();
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.groups.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::RECOVERY, TebLocalPlannerReconfigureConfig::DEFAULT>(Recovery)));
//#line 124 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT::RECOVERY, TebLocalPlannerReconfigureConfig::DEFAULT>(Recovery)));
//#line 245 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      Default.convertParams();
//#line 245 "/opt/ros/kinetic/lib/python2.7/dist-packages/dynamic_reconfigure/parameter_generator_catkin.py"
      __group_descriptions__.push_back(TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr(new TebLocalPlannerReconfigureConfig::GroupDescription<TebLocalPlannerReconfigureConfig::DEFAULT, TebLocalPlannerReconfigureConfig>(Default)));
//#line 366 "/opt/ros/kinetic/share/dynamic_reconfigure/cmake/../templates/ConfigType.h.template"

      for (std::vector<TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr>::const_iterator i = __group_descriptions__.begin(); i != __group_descriptions__.end(); ++i)
      {
        __description_message__.groups.push_back(**i);
      }
      __max__.__toMessage__(__description_message__.max, __param_descriptions__, __group_descriptions__);
      __min__.__toMessage__(__description_message__.min, __param_descriptions__, __group_descriptions__);
      __default__.__toMessage__(__description_message__.dflt, __param_descriptions__, __group_descriptions__);
    }
    std::vector<TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr> __param_descriptions__;
    std::vector<TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr> __group_descriptions__;
    TebLocalPlannerReconfigureConfig __max__;
    TebLocalPlannerReconfigureConfig __min__;
    TebLocalPlannerReconfigureConfig __default__;
    dynamic_reconfigure::ConfigDescription __description_message__;

    static const TebLocalPlannerReconfigureConfigStatics *get_instance()
    {
      // Split this off in a separate function because I know that
      // instance will get initialized the first time get_instance is
      // called, and I am guaranteeing that get_instance gets called at
      // most once.
      static TebLocalPlannerReconfigureConfigStatics instance;
      return &instance;
    }
  };

  inline const dynamic_reconfigure::ConfigDescription &TebLocalPlannerReconfigureConfig::__getDescriptionMessage__()
  {
    return __get_statics__()->__description_message__;
  }

  inline const TebLocalPlannerReconfigureConfig &TebLocalPlannerReconfigureConfig::__getDefault__()
  {
    return __get_statics__()->__default__;
  }

  inline const TebLocalPlannerReconfigureConfig &TebLocalPlannerReconfigureConfig::__getMax__()
  {
    return __get_statics__()->__max__;
  }

  inline const TebLocalPlannerReconfigureConfig &TebLocalPlannerReconfigureConfig::__getMin__()
  {
    return __get_statics__()->__min__;
  }

  inline const std::vector<TebLocalPlannerReconfigureConfig::AbstractParamDescriptionConstPtr> &TebLocalPlannerReconfigureConfig::__getParamDescriptions__()
  {
    return __get_statics__()->__param_descriptions__;
  }

  inline const std::vector<TebLocalPlannerReconfigureConfig::AbstractGroupDescriptionConstPtr> &TebLocalPlannerReconfigureConfig::__getGroupDescriptions__()
  {
    return __get_statics__()->__group_descriptions__;
  }

  inline const TebLocalPlannerReconfigureConfigStatics *TebLocalPlannerReconfigureConfig::__get_statics__()
  {
    const static TebLocalPlannerReconfigureConfigStatics *statics;

    if (statics) // Common case
      return statics;

    boost::mutex::scoped_lock lock(dynamic_reconfigure::__init_mutex__);

    if (statics) // In case we lost a race.
      return statics;

    statics = TebLocalPlannerReconfigureConfigStatics::get_instance();

    return statics;
  }


}

#undef DYNAMIC_RECONFIGURE_FINAL

#endif // __TEBLOCALPLANNERRECONFIGURERECONFIGURATOR_H__
